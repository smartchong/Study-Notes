# 设计模式   
  项目=模块+沟通  

## 扮演的角色 
   * 组织模块 
   * 设计模块间沟通
   * 提高代码质量

## 设计原则：设计模式是设计原则的具体体现
   1. 开闭原则（扩展开放，修改关闭）webpack插件 vue插件   
   2. 单一职责原则（一个模块只做单一的事情）
   3. 依赖倒置原则（上层模块不能依赖具体的下层模块，而应该依赖于具体的抽象）
      > function restaurant(food) {
      >     var list = {
      >         food1: new food1(),
      >         food2: new food2()
      >     }
      >     return list[food];
      > }   
      > function order(food) {    
      >     return restaurant(food);
      > }
   4. 接口隔离原则（接口细化，职责单一）
   5. 迪米特法则（最小知识原则：两个模块产生沟通彼此之间知道得越少越好）中介者模式
   6. 里氏替换原则（关注继承，任何父类使用的地方都可以使用子类替换）

## 分类
   * 创建型：优雅地创建对象
     1. 工厂模式：大量创建对象
     2. 单列模式：全局一个对象
     3. 建造者模式： 精细化地组合对象
     4. 原型模式：JS灵魂   
   * 结构型：优雅地设计代码结构
     1. 外观模式：给你一个套餐
     2. 享元模式：共享来减少数量
     3. 适配器模式：用适配代替更改
     4. 桥接模式：独立出来再对接过去
     5. 装饰者模式：优雅地扩展需求
   * 行为型：模块之间行为的模式总结，帮助组织模块行为
     1. 观察者模式：模块沟通通过第三方转发
     2. 职责链模式：像生产线一样组织模块
     3. 状态模式：用状态代替判断，减少if-else分支
     4. 命令模式：用命令去解耦执行者与命令者
     5. 策略模式：算法工厂
     6. 迭代器模式：告别for循环
   * 技巧型：优化代码的技巧 
     1. 链模式：链式调用
     2. 惰性模式：机器学习
     3. 委托模式：让别人代替你收快递
     4. 等待者模式：等你们都回来吃饭，异步操作
     5. 数据访问模式：一个方便的数据管理器

## 封装与对象
### 封装的目的  
1. 定义变量不污染外部
2. 作为一个模块调用
3. 遵守开闭原则

### 好的封装
1. 变量外部不可见
2. 调用接口使用
3. 留出扩展接口

### 创建对象的设计模式
1. 工厂模式  
目的：方便大量创建对象  
应用场景：大量产出对象，如分页组件 弹窗  

2. 建造者模式
目的：组合出一个全局对象
应用场景：创建单个 庞大的组合对象，如复杂轮播图

3. 单例模式
目的：确保全局只有一个对象
应用场景：避免重复新建，避免多个对象互相干扰

## 提高复用性
### 提高复用性的目的
1. DRY原则
2. 减少代码量，节省开销 

### 提高复用性的设计模式
1. 桥接模式
目的：通过桥接减少耦合
应用场景：减少模块耦合

2. 享元模式
目的：减少对象/代码数量
应用场景：代码中创建了大量类似的对象和类似的代码块

3. 模板方法模式
目的：定义一系列操作的骨架，简化后面类似操作的内容
应用场景：当项目中出现很多类似操作内容

